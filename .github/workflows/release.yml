name: Release public Lambda layer

on:
  workflow_dispatch:
    inputs:
      layer_arn_keyword:
        description: 'Clone layer from keyword ARN by substituting architecture parameter (ie: arn:aws:lambda:us-east-1:012345678912:layer:opentelemetry-nodejs-wrapper-<ARCHITECTURE>-d8b20954c3284abcd08f5fb8178986a89cff7160:1)'
        required: true
      layer_name_keyword:
        description: 'Publish layer to keyword name by substituting architecture parameter (ie: opentelemetry-python-<ARCHITECTURE>-ver-1-7-1)'
        required: true
      aws_region:
        description: 'Deploy to aws region'
        required: true
        default: "[ \"us-east-1\", \"us-east-2\", \"us-west-1\", \"us-west-2\", \"ap-south-1\", \"ap-northeast-2\", \"ap-southeast-1\", \"ap-southeast-2\", \"ap-northeast-1\", \"ca-central-1\", \"eu-central-1\", \"eu-west-1\", \"eu-west-2\", \"eu-west-3\", \"eu-north-1\", \"sa-east-1\" ]"
      architecture:
        # NOTE: (NathanielRN) The operator should be extra cautious if they are
        # trying to modify the release "architecture" input, because the only
        # reason they would is if the Soak Test Layer ARN Keyword only worked
        # for ONE architecture and FAILED for the other and at the point we
        # should be really certain that we want to release such a layer.
        description: 'Architecture-compatible distributions of the layer to release in each region'
        required: true
        default: "[ \"amd64\", \"arm64\" ]"

permissions:
  id-token: write
  contents: read

jobs:
  validate-inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Validate `layer_name_keyword` (${{ github.event.inputs.layer_name_keyword }})
        run: |
          grep -Eq "opentelemetry-(collector|java-agent|java-wrapper|nodejs|python)-<ARCHITECTURE>-ver-[0-9]+-[0-9]+-[0-9]+" <<< "${{ github.event.inputs.layer_name_keyword }}"
  publish-prod:
    runs-on: ubuntu-latest
    needs: validate-inputs
    strategy:
      matrix:
        architecture: ${{ fromJson(github.event.inputs.architecture) }}
        aws_region: ${{ fromJson(github.event.inputs.aws_region) }}
    steps:
      - uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.INTEG_TEST_LAMBDA_ROLE_ARN }}
          role-duration-seconds: 1200
          aws-region: us-east-1
      - name: Get layer ARN by substituting `${{ matrix.architecture }}` into Soak Test ARN keyword
        run: |
          echo LAYER_ARN=$(echo "${{ github.event.inputs.layer_arn_keyword }}" | sed 's/<ARCHITECTURE>/${{ matrix.architecture }}/') | tee --append $GITHUB_ENV
      - name: Get layer name by substituting `${{ matrix.architecture }}` into Workflow Input name keyword
        run: |
          echo LAYER_NAME=$(echo "${{ github.event.inputs.layer_name_keyword }}" | sed 's/<ARCHITECTURE>/${{ matrix.architecture }}/') | tee --append $GITHUB_ENV
      - name: Get layer kind by parsing `${{ github.event.inputs.layer_name_keyword }}`
        run: |
          echo LAYER_KIND=$(echo "${{ github.event.inputs.layer_name_keyword }}" | cut -d - -f 3) | tee --append $GITHUB_ENV
      - name: download layer from source
        run: |
          URL=$(aws lambda get-layer-version-by-arn --arn ${{ env.LAYER_ARN }} --query Content.Location --output text)
          curl $URL -o layer.zip
      # switch to prod
      - uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.PROD_LAMBDA_ROLE_ARN }}
          role-duration-seconds: 1200
          aws-region: ${{ matrix.aws_region }}
          mask-aws-account-id: false
      - name: Get bucket name for release run
        run: |
          echo BUCKET_NAME=publish-${{ env.LAYER_KIND }}-${{ matrix.architecture }}-${{ github.run_id }}-${{ matrix.aws_region }} | tee --append $GITHUB_ENV
      - name: publish
        run: |
          aws s3 mb s3://${{ env.BUCKET_NAME }}
          aws s3 cp layer.zip s3://${{ env.BUCKET_NAME }}
          layerARN=$(
            aws lambda publish-layer-version \
              --layer-name ${{ env.LAYER_NAME }} \
              --content S3Bucket=${{ env.BUCKET_NAME }},S3Key=layer.zip \
              --query 'LayerVersionArn' \
              --output text
          )
          echo $layerARN
          mkdir ${{ env.LAYER_NAME }}
          echo $layerARN > ${{ env.LAYER_NAME }}/${{ matrix.aws_region }}
          cat ${{ env.LAYER_NAME }}/${{ matrix.aws_region }}
      - name: public layer
        run: |
          layerVersion=$(
            aws lambda list-layer-versions \
              --layer-name ${{ env.LAYER_NAME }} \
              --query 'max_by(LayerVersions, &Version).Version'
          )
          aws lambda add-layer-version-permission \
            --layer-name ${{ env.LAYER_NAME }} \
            --version-number $layerVersion \
            --principal "*" \
            --statement-id publish \
            --action lambda:GetLayerVersion
      - name: upload layer arn artifact
        if: ${{ success() }}
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.LAYER_NAME }}
          path: ${{ env.LAYER_NAME }}/${{ matrix.aws_region }}
      - name: clean s3
        if: always()
        run: |
          aws s3 rb --force s3://${{ env.BUCKET_NAME }}
  generate-note:
    runs-on: ubuntu-latest
    needs: publish-prod
    strategy:
      matrix:
        architecture: ${{ fromJson(github.event.inputs.architecture) }}
    steps:
      - uses: hashicorp/setup-terraform@v2
      - name: Get layer name by substituting `${{ matrix.architecture }}` into Workflow Input name keyword
        run: |
          echo LAYER_NAME=$(echo "${{ github.event.inputs.layer_name_keyword }}" | sed 's/<ARCHITECTURE>/${{ matrix.architecture }}/') | tee --append $GITHUB_ENV
      - name: Get layer kind by parsing `${{ github.event.inputs.layer_name_keyword }}`
        run: |
          echo LAYER_KIND=$(echo "${{ github.event.inputs.layer_name_keyword }}" | cut -d - -f 3) | tee --append $GITHUB_ENV
      - name: download layerARNs
        uses: actions/download-artifact@v3
        with:
          name: ${{ env.LAYER_NAME }}
          path: ${{ env.LAYER_NAME }}
      - name: show layerARNs
        run: |
          for file in ${{ env.LAYER_NAME }}/*
          do
          echo $file
          cat $file
          done
      - name: generate layer-note
        working-directory: ${{ env.LAYER_NAME }}
        run: |
          echo "| Region | Layer ARN |" >> ../layer-note
          echo "|  ----  | ----  |" >> ../layer-note
          for file in *
          do
          read arn < $file
          echo "| " $file " | " $arn " |" >> ../layer-note
          done
          cd ..
          cat layer-note
      - name: generate tf layer
        working-directory: ${{ env.LAYER_NAME }}
        run: |
          echo "locals {" >> ../layer.tf
          if [ "${{ env.LAYER_KIND }}" != 'collector' ]
          then
            echo "  sdk_layer_arns_${{ matrix.architecture }} = {" >> ../layer.tf
          else
            echo "  collector_layer_arns_${{ matrix.architecture }} = {" >> ../layer.tf
          fi
          for file in *
          do
          read arn < $file
          echo "    \""$file"\" = \""$arn"\"" >> ../layer.tf
          done
          cd ..
          echo "  }" >> layer.tf
          echo "}" >> layer.tf
          terraform fmt layer.tf
          cat layer.tf
      - name: upload layer tf file
        uses: actions/upload-artifact@v3
        with:
          name: layer_${{ matrix.architecture }}.tf
          path: layer.tf
